function [od] = advance_pop(in,od)
%
% [od] = advance_pop(in,od)
%
% This function advances or initializes the population. The population is
% initialized randomly throughout the entire trade space. The velocity of
% the individuals is also computed by taking into account the cognitive and
% social influences of best solutions.
%
% Population advancing processess:
%   Set velocity - Influenced by the inertia, location of particle's best
%                   solution (cognitive influence), and location of best neighbor
%                   (social influence)
%   Move individuals - Perform step in velocity direction for each individual.
%                       If individual would exceed limits of trade space, then
%                       the individual is placed on the boundary and the
%                       velocity is negated (resulting in an effective
%                       "bouncing" off the boundary) or the individual is placed
%                       on the boundary at rest.
%
% Input:
%   in - structure containing inputs from input deck
%   od - structure containing variables of interest during optimization
%
% Output:
%   od - structure containing variables of interest during optimization
%

% Author: Michael J. Grant - NASA/JSC/DM42 in Jan. 2006


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Set Values Constant for Iteration %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[od] = set_constants(in,od);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Update/initialize velocity %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[od] = set_velocity(in,od);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Update/initialize position %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[od] = set_position(in,od);

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [od] = set_constants(in,od)
%
% [od] = set_constants(od,in)
%
% This function assigns the three coefficients used in the velocity
% calculations:
%   r1 - Cognitive parameter
%   r2 - Social parameter
%   w - Inertia
%
% Input:
%   in - structure containing inputs from input deck
%   od - structure containing variables of interest during optimization
%
% Output:
%   od - structure containing variables of interest during optimization
%

% Author: Michael J. Grant - NASA/JSC/DM42 in Jan. 2006


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Set Velocity Constants %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Determine if first iteration
if od.iter == 1
  % Initializing
  od.r1(od.iter) = NaN; % Cognitive parameter
  od.r2(od.iter) = NaN; % Social parameter
  od.w(od.iter) = NaN; % Inertia
else
  % Advancing population
  od.r1(od.iter) = rand; % Cognitive parameter
  od.r2(od.iter) = rand; % Social parameter
  [od] = set_inertia(in,od); % Inertia
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [od] = set_inertia(in,od)
%
% [od] = set_inertia(in,od);
%
% This function calculates the inertia associated with the iteration. Initially,
% the inertia is set "high" to promote global searching and is reduced as the
% iterations progress to promote local searching.
%
% Input:
%   in - structure containing inputs from input deck
%   od - structure containing variables of interest during optimization
%
% Output:
%   od - structure containing variables of interest during optimization
%

% Author: Michael J. Grant - NASA/JSC/DM42 in Jan. 2006


%%%%%%%%%%%%%%%%%%%%%%
%% Compute Inertia  %%
%%%%%%%%%%%%%%%%%%%%%%

% Inertia computed based on type of decay
switch in.w_type

  %%%%%%%%%%%%
  %% Linear %%
  %%%%%%%%%%%%
  
  % Inertia linearly decays to a value = initial inertia - 1
  
  case 'linear'
    
    inertia = in.w_init - od.iter/in.max_iter;

  %%%%%%%%%%%%%%%
  %% Quadratic %%
  %%%%%%%%%%%%%%%
  
  % Inertia quadratically decays from initial value to zero at max iterations
  
  case 'quadratic'

    inertia = in.w_init/(1-in.max_iter)^2*(od.iter-in.max_iter)^2;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Coefficient of Variance %%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  % Inertia is decremented in a step process when the coefficient of variance is
  % below a given tolerance.
  
  case 'cov'

    % Current best fitness set
    fitness = od.bestSoFar(1,:,od.iter-1);

    % Obtain top fitness values
    [fitness_sorted,I] = sort(fitness);
    upper_value = ceil(length(fitness)*in.cov_per);
    fitness_set = fitness_sorted(1:upper_value);

    % Determine cofficient of variance (COV) of fitness values
    sigma = std(fitness_set); % Standard deviation
    mu = mean(fitness_set); % Mean
    od.cov(od.iter) = abs(sigma/mu); % COV

    % Initialize inertia if necessary
    if od.iter == 2
      od.w(od.iter-1) = in.w_init;
    end

    % If coefficient of variance below tolerance, then assume solution 
    % converging ==> Decrement inertia
    if od.cov(od.iter) < in.cov_tol
      od.w(od.iter) = od.w(od.iter-1)*in.w_factor;
    else
      od.w(od.iter) = od.w(od.iter-1);
    end
    
  otherwise
    
    error('Invalid in.w_type value.');
    
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [od] = set_velocity(in,od)
%
% [od] = set_velocity(in,od)
%
% This function computes the velocity for each individual. This determines how
% the population moves about the trade space.
%
% Input:
%   in - structure containing inputs from input deck
%   od - structure containing variables of interest during optimization
%
% Output:
%   od - structure containing variables of interest during optimization
%

% Author: Michael J. Grant - NASA/JSC/DM42 in Jan. 2006


%%%%%%%%%%%%%%%%%%
%% Set Velocity %%
%%%%%%%%%%%%%%%%%%

% Determine if first iteration for initialization
if od.iter == 1

  % Randomly initialize velocity
  rand_mat = rand(od.dim,in.num_ind);
  diff_mat = in.vel_max - in.vel_min;
  od.vel(:,:,od.iter) = rand_mat.*diff_mat(:,ones(size(rand_mat,2),1)) + ...
    in.vel_min(:,ones(size(rand_mat,2),1));

else
  
  %%%%%%%%%%%%%%%%%%%%%
  %% Update Velocity %%
  %%%%%%%%%%%%%%%%%%%%%
  
  % Inertia component of velocity
  term1 = od.w(od.iter)*od.vel(:,:,od.iter-1);
  
  % Cognative (best remembered) component of velocity
  term2 = in.c1*od.r1(od.iter)*(od.best(:,:,od.iter-1) - od.pop(:,:,od.iter-1));
  
  % Social (best neighbor) component of velocity
  term3 = in.c2*od.r2(od.iter)*(od.best_nbr(:,:,od.iter-1) - ...
    od.pop(:,:,od.iter-1));
  
  % Update velocity
  od.vel(:,:,od.iter) = in.X*(term1 + term2 + term3);

  %%%%%%%%%%%%%%%%%%%%%%%%
  %% Constrain Velocity %%
  %%%%%%%%%%%%%%%%%%%%%%%%
  
  % Determine size of velocity matrix for indexing bias
  [row,col] = size(od.vel(:,:,od.iter));
  
  % Determine indexing bias based on third dimension (iteration number)
  index_bias = row*col*(od.iter-1);
  
  % Construct matrix of min vel that is the same size as the vel matrix
  temp_vel = in.vel_min(:,ones(size(od.vel,2),1));
  
  % Determine indices of velocity components that exceed constraints
  I = find(od.vel(:,:,od.iter) - temp_vel < 0);
  
  % Force velocity components to be at boundary of constraint
  od.vel(I+index_bias) = temp_vel(I);
  
  % Construct matrix of max vel that is the same size as the vel matrix
  temp_vel = in.vel_max(:,ones(size(od.vel,2),1));
  
  % Determine indices of velocity components that exceed constraints
  I = find(od.vel(:,:,od.iter) - temp_vel > 0);
  
  % Force velocity components to be at boundary of constraint
  od.vel(I+index_bias) = temp_vel(I);
  
  
end

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [od] = set_position(in,od)
%
% [od] = set_position(in,od)
%
% This function advances/initializes the population based on the velocity
% calculations.
%
% Input:
%   in - structure containing inputs from input deck
%   od - structure containing variables of interest during optimization
%
% Output:
%   od - structure containing variables of interest during optimization
%

% Author: Michael J. Grant - NASA/JSC/DM42 in Jan. 2006


%%%%%%%%%%%%%%%%%%
%% Set Position %%
%%%%%%%%%%%%%%%%%%

if od.iter == 1

  % Randomly initialize position (potentially covering entire trade space)
  rand_mat = rand(od.dim,in.num_ind);
  diff_mat = in.pos_max - in.pos_min;
  od.pop(:,:,od.iter) = rand_mat.*diff_mat(:,ones(size(rand_mat,2),1)) + ...
    in.pos_min(:,ones(size(rand_mat,2),1));
  
  % Determine infeasible solutions and re-initialize infeasible solutions until
  % have entire population with a feasible initial guess
  
  % Compute fitness of population
  [od.fit(:,:,od.iter)] = fitness_func(od.pop(:,:,od.iter),in);
  
  % Determine infeasible solutions
  [R,C] = find(isnan(od.fit(:,:,od.iter)) == 1);
  C = unique(C);
  
  % Change infeasible solutions to feasible (randomly)
  % Iterate until have all feasible solutions
  length_old = length(C);
  while ~isempty(C)
    
    % Modify initial guess of infeasible solutions
    rand_mat = rand(od.dim,length(C));
    diff_mat = in.pos_max - in.pos_min;
    od.pop(:,C,od.iter) = rand_mat.*diff_mat(:,ones(size(rand_mat,2),1)) + ...
      in.pos_min(:,ones(size(rand_mat,2),1));
    
    % Evaluate fitness of new solutions
    [od.fit(:,C,od.iter)] = fitness_func(od.pop(:,C,od.iter),in);
    
    % Determine infeasible solutions
    [R,C] = find(isnan(od.fit(:,:,od.iter)) == 1);
    C = unique(C);
    
    length_new = length(C);
    
    % Output to scr
    if length_new < length_old
      length_new
      length_old = length_new;
    end

  end

else
  
  %%%%%%%%%%%%%%%%%%%%%
  %% Update Position %%
  %%%%%%%%%%%%%%%%%%%%%
  
  % Move each individual in population
  od.pop(:,:,od.iter) = od.pop(:,:,od.iter-1) + od.vel(:,:,od.iter);

  % Determine size of velocity matrix for indexing bias
  [row,col] = size(od.pop(:,:,od.iter));
  % Determine indexing bias based on third dimension (iteration number)
  index_bias = row*col*(od.iter-1);

  % Determine if upper bound exceeded. If so, place particle at wall
  temp_pos = in.pos_max(:,ones(size(od.pop,2),1));
  I_upper = find(od.pop(:,:,od.iter) > temp_pos);
  od.pop(I_upper+index_bias) = temp_pos(I_upper);

  % Determine if lower bound exceeded. If so, place particle at wall
  temp_pos = in.pos_min(:,ones(size(od.pop,2),1));
  I_lower = find(od.pop(:,:,od.iter) < temp_pos);
  od.pop(I_lower+index_bias) = temp_pos(I_lower);

  % Listing of changed dimensions
  I = union(I_upper,I_lower);

  % Bounce or set vel to zero for vel components that exceed constraint
  value = floor(2*rand(1,length(I))); % Randomly choose bounce/rest
  
  % Bounce
  I_bounce = find(value >= 1);
  od.vel(I_bounce+index_bias) = -od.vel(I_bounce+index_bias);
  
  % Set velocity to zero
  I_stop = find(value < 1);
  od.vel(I_stop+index_bias) = 0;

end

return

